/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma  alloc_text (PAGE, PcieForDSPEvtDeviceAdd)
#pragma  alloc_text (PAGE,PcieForDSPEvtDriverContextCleanup)
#pragma  alloc_text (PAGE,PcieForDspPreparaHardware)
#pragma  alloc_text (PAGE,PcieForDspReleaseHardware)
#pragma  alloc_text (PAGE,PcieForDspDeviceD0Entry)
#pragma  alloc_text (PAGE,PcieForDspDeviceD0Exit)
#pragma  alloc_text (PAGE,PcieInitializeDeviceContext)
#endif

//
//NTSTATUS
//PcieForDSPCreateDevice(
//    _Inout_ PWDFDEVICE_INIT DeviceInit
//    )
///*++
//
//Routine Description:
//
//    Worker routine called to create a device and its software resources.
//
//Arguments:
//
//    DeviceInit - Pointer to an opaque init structure. Memory for this
//                    structure will be freed by the framework when the WdfDeviceCreate
//                    succeeds. So don't access the structure after that point.
//
//Return Value:
//
//    NTSTATUS
//
//--*/
//{
//    WDF_OBJECT_ATTRIBUTES         deviceAttributes;
//    PDEVICE_CONTEXT               deviceContext;
//    WDFDEVICE                     device;
//    NTSTATUS                      status;
//	WDF_PNPPOWER_EVENT_CALLBACKS  pnpPowerCallbacks;
//
//    PAGED_CODE();
//
//	
//
//
//    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);
//
//    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);
//
//    if (NT_SUCCESS(status)) {
//        //
//        // Get a pointer to the device context structure that we just associated
//        // with the device object. We define this structure in the device.h
//        // header file. DeviceGetContext is an inline function generated by
//        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
//        // This function will do the type checking and return the device context.
//        // If you pass a wrong object handle it will return NULL and assert if
//        // run under framework verifier mode.
//        //
//        deviceContext = DeviceGetContext(device);
//
//        //
//        // Initialize the context.
//        //
//        deviceContext->PrivateDeviceData = 0;
//
//        //
//        // Create a device interface so that applications can find and talk
//        // to us.
//        //
//        status = WdfDeviceCreateDeviceInterface(
//            device,
//            &GUID_DEVINTERFACE_PcieForDSP,
//            NULL // ReferenceString
//            );
//
//        if (NT_SUCCESS(status)) {
//            //
//            // Initialize the I/O Package and any Queues
//            //
//            status = PcieForDSPQueueInitialize(device);
//        }
//    }
//
//    return status;
//}

NTSTATUS
PcieForDSPEvtDeviceAdd(
_In_    WDFDRIVER       Driver,
_Inout_ PWDFDEVICE_INIT DeviceInit
)
/*++
Routine Description:

EvtDeviceAdd is called by the framework in response to AddDevice
call from the PnP manager. We create and initialize a device object to
represent a new instance of the device.

Arguments:

Driver - Handle to a framework driver object created in DriverEntry

DeviceInit - Pointer to a framework-allocated WDFDEVICE_INIT structure.

Return Value:

NTSTATUS

--*/
{
	NTSTATUS                      status;
	WDF_OBJECT_ATTRIBUTES         attributes;
	PDEVICE_CONTEXT               devExt;
	WDFDEVICE                     device;
	WDF_PNPPOWER_EVENT_CALLBACKS  pnpPowerCallbacks;

	UNREFERENCED_PARAMETER(Driver);

	PAGED_CODE();// zhu  PAGED_CODE表示该代码占用分页内存，如果不说明，则占用系统的非分页内存

	//TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

	// 读、写请求的缓冲方式
	// 默认为Buffered方式，另外两种方式是Direct和Neither。
	WdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoBuffered);

	// 注册PNP与Power回调函数

	// zhu
	// Zero out the PnpPowerCallbacks structure.
	WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);

	// zhu
	// Set Callbacks for any of the functions we are interested in.
	// If no callback is set, Framework will take the default action
	// by itself.
	pnpPowerCallbacks.EvtDevicePrepareHardware = PcieForDspPreparaHardware;
	pnpPowerCallbacks.EvtDeviceReleaseHardware = PcieForDspReleaseHardware;

	//
	// These two callbacks set up and tear down hardware state that must be
	// done every time the device moves in and out of the D0-working state.
	//
	pnpPowerCallbacks.EvtDeviceD0Entry = PcieForDspDeviceD0Entry;  // hu 进入和退出D0状态时候的回调函数
	pnpPowerCallbacks.EvtDeviceD0Exit = PcieForDspDeviceD0Exit;   // hu 在此状态下，计算机在全功耗和全功能下运行

	// zhu
	// Register the PnP Callbacks..
	WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

	// zhu
	// 设定设备环境块长度
	// 宏内部会调用sizeof(DEVICE_CONTEXT)求结构体长度
	// Initialize Fdo Attributes.
	// hu 分配一个DEVICE_CONTEXT的内存块，并且将内存块的指针保存到WDF_OBJECT_ATTRIBUTES里面
	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&attributes, DEVICE_CONTEXT);

	// zhu
	// By opting for SynchronizationScopeDevice, we tell the framework to
	// synchronize callbacks events of all the objects directly associated
	// with the device. In this driver, we will associate queues and
	// and DpcForIsr. By doing that we don't have to worrry about synchronizing
	// access to device-context by Io Events and DpcForIsr because they would
	// not concurrently ever. Framework will serialize them by using an
	// internal device-lock.
	attributes.SynchronizationScope = WdfSynchronizationScopeDevice;

	// zhu
	// 创建WDF设备
	status = WdfDeviceCreate(&DeviceInit, &attributes, &device);
	if (!NT_SUCCESS(status))
	{
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,"WdfDeviceCreate failed %!STATUS!", status);
		return status;
	}

	//status = PcieForDSPCreateDevice(DeviceInit);

	// Get the DeviceExtension and initialize it. PcieGetDeviceContext is an inline function
	// defined by WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in the
	// private header file. This function will do the type checking and return
	// the device context. If you pass a wrong object a wrong object handle
	// it will return NULL and assert if run under framework verifier mode.
	//
	devExt = DeviceGetContext(device);
	devExt->Device = device;

	//
	// Tell the Framework that this device will need an interface
	//
	// NOTE: See the note in Public.h concerning this GUID value.
	//
	status = WdfDeviceCreateDeviceInterface(device,
		(LPGUID)&GUID_XILINX_PCI_INTERFACE,
		NULL);

	if (!NT_SUCCESS(status))
	{
//#ifdef DEBUG_HU
//		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
//			"WdfDeviceCreateDeviceInterface failed %!STATUS!", status);
//#endif
		return status;
	}



	// Initalize the Device Extension.
	//
	status = PcieInitializeDeviceContext(devExt);

	if (!NT_SUCCESS(status))
	{
		//TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
		//	"PcieInitializeDeviceContext failed %!STATUS!", status);

		return status;
	}

	//TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");

	return status;
}

VOID
PcieForDSPEvtDriverContextCleanup(
_In_ WDFOBJECT DriverObject
)
/*++
Routine Description:

Free all the resources allocated in DriverEntry.

Arguments:

DriverObject - handle to a WDF Driver object.

Return Value:

VOID.

--*/
{
	UNREFERENCED_PARAMETER(DriverObject);

	PAGED_CODE();

	//TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

	//
	// Stop WPP Tracing
	//
	WPP_CLEANUP(WdfDriverWdmGetDriverObject(DriverObject));

}


/*  zhu 
 *  程序描述：
 *  在启动设备需要初始化时运行，建立一个DMA通道和任一I/O端口。该函数只在设备启动或重启时调用。
 *
 *  参数：
 *  Device - 指向WDFDEVICE的句柄
 *  Resources - 与设备相关联的PNP resources，对于PCI设备，大部分时间无效
 *  ResourcesTranslated - 与设备相关联的translated PnP resources，对于PCI设备很重要
 *
 *  返回值：
 *  NT status code - failure will result in the device stack being torn down
 */
NTSTATUS
PcieForDspPreparaHardware(
WDFDEVICE     Device,
WDFCMRESLIST  Resources,
WDFCMRESLIST  ResourcesTranslated
)
{
	NTSTATUS         status = STATUS_SUCCESS;
	PDEVICE_CONTEXT   devExt;
	ULONG i;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR  desc;

	UNREFERENCED_PARAMETER(Resources);

	PAGED_CODE();

//#ifdef DEBUG_HU
//	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");
//#endif

	devExt = DeviceGetContext(Device);

	//
	// Parse the resource list and save the resource information.
	//
	for (i = 0; i < 5/*WdfCmResourceListGetCount(ResourcesTranslated)*/; i++) 
	{

		desc = WdfCmResourceListGetDescriptor(ResourcesTranslated, i);

		if (!desc)
		{
			status = STATUS_DEVICE_CONFIGURATION_ERROR;
#ifdef DEBUG_HU
			TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
				"WdfCmResourceListGetDescriptor failed %!STATUS!", status);
#endif
			return status;
		}

		switch (desc->Type)
		{
		case CmResourceTypeMemory:
			//
			// hu 将物理地址映射到虚拟地址
			// 
			//devExt->MemBarBase = (PUCHAR)MmMapIoSpace(desc->u.Memory.Start,
			//	desc->u.Memory.Length,
			//	MmNonCached);
			//devExt->MemBarLength = desc->u.Memory.Length;

			if (i == 0)
			{
				devExt->PhysicalAddressRegister = desc->u.Memory.Start.LowPart;
				devExt->MemBar0Base = (PUCHAR)MmMapIoSpace(
					desc->u.Memory.Start,
					desc->u.Memory.Length,
					MmNonCached);
				devExt->MemBar0Length = desc->u.Memory.Length;
			}
			if (i == 2)
			{
				devExt->MemBar1Base = (PUCHAR)MmMapIoSpace(
					desc->u.Memory.Start,
					desc->u.Memory.Length,
					MmNonCached);
				devExt->MemBar1Length = desc->u.Memory.Length;
			}

			devExt->MemBar2Base = (PUCHAR)MmMapIoSpace(
				desc->u.Memory.Start,
				desc->u.Memory.Length,
				MmNonCached);
			devExt->MemBar2Length = desc->u.Memory.Length;



#ifdef DEBUG_HU
			TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
				" - Memory Resource [%I64X-%I64X] BAR%d",
				desc->u.Memory.Start.QuadPart,
				desc->u.Memory.Start.QuadPart +
				desc->u.Memory.Length,
				i);
#endif
			DbgPrint("zhu:AType[%I64X--%I64X]  BAR%d", desc->u.Memory.Start.QuadPart, desc->u.Memory.Start.QuadPart + desc->u.Memory.Length - 1, i);
			break;
		
		default:
			DbgPrint("zhu: i=%u not case the CmResourceTypeMemory!",i);
			break;
		}
	}

	if ((!devExt->MemBar2Base) && (!devExt->MemBar0Base) && (!devExt->MemBar1Base) )
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
#ifdef DEBUG_HU
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
			"PcieMapResources: Missing resources BAR0");
#endif
		return status;
	}


#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");
#endif
	return status;
}


/*  zhu
 *  程序描述：
 *  取消PcieForDspPreparaHardware中的映射。在设备因resource rebalance,surprise-removed or query-removed被停止时调用
 *
 *  参数：
 *  Device - 指向WDFDEVICE的句柄
 *  ResourcesTranslated - 与设备相关联的translated PnP resources，对于PCI设备很重要
 *
 *  返回值：
 *  NT status code - failure will result in the device stack being torn down
 */
NTSTATUS
PcieForDspReleaseHardware(
WDFDEVICE     Device,
WDFCMRESLIST  ResourcesTranslated
)
{

	NTSTATUS status = STATUS_SUCCESS;
	PDEVICE_CONTEXT   devExt;

	UNREFERENCED_PARAMETER(ResourcesTranslated);

	PAGED_CODE();

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");
#endif

	devExt = DeviceGetContext(Device);

	if (devExt->MemBar0Base)
	{
		MmUnmapIoSpace(devExt->MemBar0Base, devExt->MemBar0Length);
		devExt->MemBar0Base = NULL;
		devExt->MemBar0Length = 0;
	}
	if (devExt->MemBar1Base)
	{
		MmUnmapIoSpace(devExt->MemBar1Base, devExt->MemBar1Length);
		devExt->MemBar1Base = NULL;
		devExt->MemBar1Length = 0;
	}
	if (devExt->MemBar2Base)
	{
		MmUnmapIoSpace(devExt->MemBar2Base, devExt->MemBar2Length);
		devExt->MemBar2Base = NULL;
		devExt->MemBar2Length = 0;
	}

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");
#endif
	return status;
}

/*
*  程序描述：
*  取消PcieForDspPreparaHardware中的映射。在设备因resource rebalance,surprise-removed or query-removed被停止时调用
*
*  参数：
*  Device - 指向WDFDEVICE的句柄
*  ResourcesTranslated - 与设备相关联的translated PnP resources，对于PCI设备很重要
*
*  返回值：
*  NT status code - failure will result in the device stack being torn down
*/
NTSTATUS
PcieForDspDeviceD0Entry(
_In_  WDFDEVICE Device,
_In_  WDF_POWER_DEVICE_STATE PreviousState
)
{
	NTSTATUS  status = STATUS_SUCCESS;

	UNREFERENCED_PARAMETER(Device);
	UNREFERENCED_PARAMETER(PreviousState);

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");


	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");
	return status;
}

/*
*  程序描述：
*  取消PcieForDspPreparaHardware中的映射。在设备因resource rebalance,surprise-removed or query-removed被停止时调用
*
*  参数：
*  Device - 指向WDFDEVICE的句柄
*  ResourcesTranslated - 与设备相关联的translated PnP resources，对于PCI设备很重要
*
*  返回值：
*  NT status code - failure will result in the device stack being torn down
*/
NTSTATUS
PcieForDspDeviceD0Exit(
_In_  WDFDEVICE Device,
_In_  WDF_POWER_DEVICE_STATE TargetState
)
{
	NTSTATUS  status = STATUS_SUCCESS;
	PDEVICE_CONTEXT   devExt;

	PAGED_CODE();

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");

	devExt = DeviceGetContext(Device);

	switch (TargetState) {
	case WdfPowerDeviceD1:
	case WdfPowerDeviceD2:
	case WdfPowerDeviceD3:

		//
		// Fill in any code to save hardware state here.
		//

		//
		// Fill in any code to put the device in a low-power state here.
		//
		break;

	case WdfPowerDevicePrepareForHibernation:

		//
		// Fill in any code to save hardware state here.  Do not put in any
		// code to shut the device off.  If this device cannot support being
		// in the paging path (or being a parent or grandparent of a paging
		// path device) then this whole case can be deleted.
		//

		break;

	case WdfPowerDeviceD3Final:
	default:
		//
		// Reset the hardware, as we're shutting down for the last time.
		//
		//if (devExt->MemBarBase){
		//	PcieDeviceResetDMA(devExt->MemBarBase);
		//}
		break;
	}

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");

	return status;
}

NTSTATUS
PcieInitializeDeviceContext(
//_In_ PWDF_OBJECT_ATTRIBUTES Attributes,
_In_ PDEVICE_CONTEXT DevExt
)
/*++
Routine Description:

This routine is called by EvtDeviceAdd. Here the device context is
initialized and all the software resources required by the device is
allocated.

Arguments:

DevExt     Pointer to the Device Extension

Return Value:

NTSTATUS

--*/
{
	NTSTATUS    status = STATUS_SUCCESS;

	PAGED_CODE();

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");
#endif

	status = PcieForDSPQueueInitialize(DevExt);

	if (!NT_SUCCESS(status))
	{
#ifdef DEBUG_HU
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
			"PcieQueueInitialize failed: %!STATUS!", status);
#endif
		return status;
	}

	//
	// Create a WDFINTERRUPT object.
	//
	status = PcieInterruptCreate(DevExt);
	if (!NT_SUCCESS(status)) {
#ifdef DEBUG_HU
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
			"PcieInterruptCreate failed: %!STATUS!", status);
#endif
		return status;
	}

	// 
	// Init DMA hardware
	//
	status = PcieInitializeDMA(DevExt);
//	status = PcieForDspApplyMemoryBuffer(Attributes, DevExt);
	if (!NT_SUCCESS(status))
	{
		return status;
	}
	//
	// Init Timers
	//
	/*status = PcieDMATimerCreate(
		&DevExt->WriteTimer,
		DevExt->Device,
		DmaWriteTimerEventFunc);

	if (!NT_SUCCESS(status)) {	return status;	}

	status = PcieDMATimerCreate(
		&DevExt->ReadTimer,
		DevExt->Device,
		DmaReadTimerEventFunc);*/

	if (!NT_SUCCESS(status)) {	return status; }

	return status;
}
/*
NTSTATUS
PcieForDspApplyMemoryBuffer(
_In_ PWDF_OBJECT_ATTRIBUTES Attributes,
_In_ PDEVICE_CONTEXT DevExt
)
{
	NTSTATUS status;
	POOL_TYPE  PoolTag;
	WDF_OBJECT_ATTRIBUTES  attributes;
	UNREFERENCED_PARAMETER(Attributes);

	status = STATUS_SUCCESS;
	PoolTag = 0;
	

	WDF_OBJECT_ATTRIBUTES_INIT(&attributes);
	//attributes.ParentObject = requestHandle;
	status = WdfMemoryCreate(&attributes, NonPagedPool, PoolTag, (8 * 1024 * 1024), &DevExt->MemoryBuffer, &DevExt->BufferPointer);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("zhu: WdfMemoryCreate failed! 0x%x", status);
		return status;
	}
	//上个返回的错误是：  STATUS_WDF_EXECUTION_LEVEL_INVALID
	DbgPrint("zhu: -->WdfMemoryCreate successful!<--");
	return status;
}
*/

NTSTATUS
PcieInitializeDMA(
_In_ PDEVICE_CONTEXT DevExt
)
/*++
Routine Description:

Initializes the DMA adapter.

Arguments:

DevExt      Pointer to our DEVICE_EXTENSION

Return Value:

None

--*/
{
	NTSTATUS  status = STATUS_SUCCESS;
	WDF_DMA_ENABLER_CONFIG   	dmaConfig;

	PAGED_CODE();

	//#ifdef DEBUG_HU
	//	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");
	//#endif

	//
	// DMA_TRANSFER_ELEMENTS must be 128-byte aligned
	//
	WdfDeviceSetAlignmentRequirement(DevExt->Device,
		/*PCI_DTE_ALIGNMENT_16 ); */
		FILE_128_BYTE_ALIGNMENT);

	//
	// Create a new DMA Enabler instance.
	// Use Scatter/Gather, 32-bit Addresses, Duplex-type profile.
	//
	WDF_DMA_ENABLER_CONFIG_INIT(&dmaConfig,
		//#ifdef SUPPORT_DMA64
		//		WdfDmaProfileScatterGather64Duplex,
		//#else
		WdfDmaProfileScatterGatherDuplex,
		//#endif
		MAX_DMA_SIZE_COMMONBUFFER);

	//#ifdef DEBUG_HU
	//	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
	//		"The DMA Profile is WdfDmaProfileScatterGatherDuplex");
	//#endif

	status = WdfDmaEnablerCreate(DevExt->Device,
		&dmaConfig,
		WDF_NO_OBJECT_ATTRIBUTES,
		&DevExt->DmaEnabler);

	if (!NT_SUCCESS(status)) {
		//#ifdef DEBUG_HU
		//		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
		//			"WdfDmaEnablerCreate failed: %!STATUS!", status);
		//#endif
		return status;
	}

	//
	// Allocate common buffer
	//
	// NOTE: This common buffer will not be cached.
	//       Perhaps in some future revision, cached option could
	//       be used. This would have faster access, but requires
	//       flushing before starting the DMA in PcieStartReadDma.
	//
	DevExt->CommonBufferSize = MAX_DMA_SIZE_COMMONBUFFER;

	status = WdfCommonBufferCreate(DevExt->DmaEnabler,
		DevExt->CommonBufferSize,
		WDF_NO_OBJECT_ATTRIBUTES,
		&DevExt->CommonBuffer);

	if (!NT_SUCCESS(status)) {
		//#ifdef DEBUG_HU
		//		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
		//			"WdfCommonBufferCreate failed %!STATUS!", status);
		//#endif
		return status;
	}

	//zhu 获取驱动程序可以访问的缓冲区的虚拟地址
	DevExt->CommonBufferBase =
		(PUCHAR)WdfCommonBufferGetAlignedVirtualAddress(DevExt->CommonBuffer);
	//zhu 获取设备可以访问的缓冲区的逻辑地址
	DevExt->CommonBufferBaseLA =
		WdfCommonBufferGetAlignedLogicalAddress(DevExt->CommonBuffer);

	RtlZeroMemory(DevExt->CommonBufferBase,
		DevExt->CommonBufferSize);

	//#ifdef DEBUG_HU
	//	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
	//		"CommonBuffer  0x%p  (#0x%I64X), length %I64d",
	//		DevExt->CommonBufferBase,
	//		DevExt->CommonBufferBaseLA.QuadPart,
	//		WdfCommonBufferGetLength(DevExt->CommonBuffer));
	//#endif
	//
	//#ifdef DEBUG_HU
	//	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");
	//#endif
	return status;
}